"""
This scripts extracts collaborations and publications for each professor in each year
"""

import argparse
import json
from collections import defaultdict
import pandas as pd
from pathlib import Path
from lxml import etree

def main():
    parser = argparse.ArgumentParser(
        prog='download_professor_pids',
        description='Download professors pages from DBLP')
    parser.add_argument(
        '-i', '--input', default="output/professor_map.json",
        help="Professor DBLP map. Generated by 2.filter_current_professors")
    parser.add_argument(
        '-y', '--years', nargs="*", default=["2021::input/2021", "2022::input/2022", "2023::input/2023", "2024::input/2024"],
        help="List of years to consider. Use :: to separate the year number from the file name. If only the year is specified, it will load the file from input/")  
    parser.add_argument(
        '-p', '--professor-dir', default="output/pids",
        help="Directory with professors DBLP XML. Generated by 3.download_professor_pids.py")
    parser.add_argument(
        '-c', '--collaborators', default="output/collaborators.json",
        help="Resulting JSON with all collaborators")
    parser.add_argument(
        '-o', '--output', default="output/publications.json",
        help="Resulting JSON with professor publications")
    
    

    args = parser.parse_args()

    with open(args.input, "r") as f:
        professor_map = json.load(f)

    years = args.years
    professors = defaultdict(lambda: {
        "dblp": None,
        "publications": defaultdict(dict),
        "collaborators": set(),
        "years": []
    })

    for year in years:
        if "::" in year:
            year, year_file = year.split("::", 1)
        else:
            year_file = Path("input") / year
        with open(year_file, "r") as f:
            for name in map(str.strip, f.readlines()):
                professors[name]["dblp"] = professor_map[name]
                professors[name]["years"].append(year)
    
    all_collaborators = defaultdict(lambda: {
        'name': None,
        'professors': set()
    })
    for name, professor in professors.items():
        for author in professor["dblp"]:
            pid = author["pid"]
            tree = etree.parse(f"{args.professor_dir}/{pid}.xml")
            root = tree.getroot()
            for year in professor["years"]:
                elements = root.xpath(f'//r/*/year[text()="{year}"]')
                for year_element in elements:
                    work = year_element.getparent()
                    authors = work.findall("author")
                    coauthors = []
                    for coauthor in authors:
                        coauthor_pid = coauthor.attrib['pid']
                        if coauthor_pid != pid:
                            coauthors.append(coauthor_pid)
                            professor["collaborators"].add(coauthor_pid)
                            all_collaborators[coauthor_pid]['name'] = coauthor.text
                            all_collaborators[coauthor_pid]['professors'].add(name)
                            if 'orcid' in coauthor.attrib:
                                all_collaborators[coauthor_pid]['orcid'] = coauthor.attrib['orcid']
                    professor["publications"][year][work.attrib['key']] = {
                        'key': work.attrib['key'],
                        'xml': etree.tostring(work).decode('utf-8'),
                        'coauthors': coauthors
                    }
        professor["collaborators"] = list(professor["collaborators"])
    
    for _, collaborator in all_collaborators.items():
        collaborator['professors'] = list(collaborator['professors'])
    Path(args.collaborators).parent.mkdir(parents=True, exist_ok=True)
    with open(args.collaborators, "w") as f:
        json.dump(all_collaborators, f)
    Path(args.output).parent.mkdir(parents=True, exist_ok=True)
    with open(args.output, "w") as f:
        json.dump(professors, f)

if __name__ == "__main__":
    main()
    